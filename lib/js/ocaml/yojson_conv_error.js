// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Printf = require("bs-platform/lib/js/printf.js");
var ListLabels = require("bs-platform/lib/js/listLabels.js");
var Yojson_conv = require("./yojson_conv.js");
var StringLabels = require("bs-platform/lib/js/stringLabels.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

function tuple_of_size_n_expected(loc, n, yojson) {
  return Yojson_conv.of_yojson_error(Curry._2(Printf.sprintf(/* Format */[
                      /* String */Block.__(2, [
                          /* No_padding */0,
                          /* String_literal */Block.__(11, [
                              "_of_yojson: tuple of size ",
                              /* Int */Block.__(4, [
                                  /* Int_d */0,
                                  /* No_padding */0,
                                  /* No_precision */0,
                                  /* String_literal */Block.__(11, [
                                      " expected",
                                      /* End_of_format */0
                                    ])
                                ])
                            ])
                        ]),
                      "%s_of_yojson: tuple of size %d expected"
                    ]), loc, n), yojson);
}

function stag_no_args(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: sum tag does not take arguments", yojson);
}

function stag_incorrect_n_args(loc, tag, yojson) {
  var msg = Curry._2(Printf.sprintf(/* Format */[
            /* String */Block.__(2, [
                /* No_padding */0,
                /* String_literal */Block.__(11, [
                    "_of_yojson: sum tag ",
                    /* Caml_string */Block.__(3, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            " has incorrect number of arguments",
                            /* End_of_format */0
                          ])
                      ])
                  ])
              ]),
            "%s_of_yojson: sum tag %S has incorrect number of arguments"
          ]), loc, tag);
  return Yojson_conv.of_yojson_error(msg, yojson);
}

function stag_takes_args(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: sum tag must be a structured value", yojson);
}

function nested_list_invalid_sum(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: a nested list is an invalid sum", yojson);
}

function empty_list_invalid_sum(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: the empty list is an invalid sum", yojson);
}

function unexpected_stag(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: unexpected sum tag", yojson);
}

function record_superfluous_fields(what, loc, rev_fld_names, yojson) {
  var fld_names_str = StringLabels.concat(" ", ListLabels.rev(rev_fld_names));
  var msg = Curry._3(Printf.sprintf(/* Format */[
            /* String */Block.__(2, [
                /* No_padding */0,
                /* String_literal */Block.__(11, [
                    "_of_yojson: ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            ": ",
                            /* String */Block.__(2, [
                                /* No_padding */0,
                                /* End_of_format */0
                              ])
                          ])
                      ])
                  ])
              ]),
            "%s_of_yojson: %s: %s"
          ]), loc, what, fld_names_str);
  return Yojson_conv.of_yojson_error(msg, yojson);
}

function record_duplicate_fields(loc, rev_fld_names, yojson) {
  return record_superfluous_fields("duplicate fields", loc, rev_fld_names, yojson);
}

function record_extra_fields(loc, rev_fld_names, yojson) {
  return record_superfluous_fields("extra fields", loc, rev_fld_names, yojson);
}

function record_get_undefined_loop(_fields, _param) {
  while(true) {
    var param = _param;
    var fields = _fields;
    if (param) {
      var match = param[0];
      _param = param[1];
      if (match[0]) {
        _fields = /* :: */[
          match[1],
          fields
        ];
        continue ;
      } else {
        continue ;
      }
    } else {
      return StringLabels.concat(" ", ListLabels.rev(fields));
    }
  };
}

function record_undefined_elements(loc, yojson, lst) {
  var $$undefined = record_get_undefined_loop(/* [] */0, lst);
  var msg = Curry._2(Printf.sprintf(/* Format */[
            /* String */Block.__(2, [
                /* No_padding */0,
                /* String_literal */Block.__(11, [
                    "_of_yojson: the following record elements were undefined: ",
                    /* String */Block.__(2, [
                        /* No_padding */0,
                        /* End_of_format */0
                      ])
                  ])
              ]),
            "%s_of_yojson: the following record elements were undefined: %s"
          ]), loc, $$undefined);
  return Yojson_conv.of_yojson_error(msg, yojson);
}

function record_list_instead_atom(loc, yojson) {
  var msg = loc + "_of_yojson: list instead of atom for record expected";
  return Yojson_conv.of_yojson_error(msg, yojson);
}

function record_poly_field_value(loc, yojson) {
  var msg = loc + "_of_yojson: cannot convert values of types resulting from polymorphic record fields";
  return Yojson_conv.of_yojson_error(msg, yojson);
}

var No_variant_match = Caml_exceptions.create("Yojson_conv_error.No_variant_match");

function no_variant_match(param) {
  throw No_variant_match;
}

function no_matching_variant_found(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: no matching variant found", yojson);
}

function ptag_no_args(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: polymorphic variant does not take arguments", yojson);
}

function ptag_incorrect_n_args(loc, cnstr, yojson) {
  var msg = Curry._2(Printf.sprintf(/* Format */[
            /* String */Block.__(2, [
                /* No_padding */0,
                /* String_literal */Block.__(11, [
                    "_of_yojson: polymorphic variant tag ",
                    /* Caml_string */Block.__(3, [
                        /* No_padding */0,
                        /* String_literal */Block.__(11, [
                            " has incorrect number of arguments",
                            /* End_of_format */0
                          ])
                      ])
                  ])
              ]),
            "%s_of_yojson: polymorphic variant tag %S has incorrect number of arguments"
          ]), loc, cnstr);
  return Yojson_conv.of_yojson_error(msg, yojson);
}

function ptag_takes_args(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: polymorphic variant tag takes an argument", yojson);
}

function nested_list_invalid_poly_var(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: a nested list is an invalid polymorphic variant", yojson);
}

function empty_list_invalid_poly_var(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: the empty list is an invalid polymorphic variant", yojson);
}

function empty_type(loc, yojson) {
  return Yojson_conv.of_yojson_error(loc + "_of_yojson: trying to convert an empty type", yojson);
}

var sprintf = Printf.sprintf;

exports.sprintf = sprintf;
exports.tuple_of_size_n_expected = tuple_of_size_n_expected;
exports.stag_no_args = stag_no_args;
exports.stag_incorrect_n_args = stag_incorrect_n_args;
exports.stag_takes_args = stag_takes_args;
exports.nested_list_invalid_sum = nested_list_invalid_sum;
exports.empty_list_invalid_sum = empty_list_invalid_sum;
exports.unexpected_stag = unexpected_stag;
exports.record_superfluous_fields = record_superfluous_fields;
exports.record_duplicate_fields = record_duplicate_fields;
exports.record_extra_fields = record_extra_fields;
exports.record_get_undefined_loop = record_get_undefined_loop;
exports.record_undefined_elements = record_undefined_elements;
exports.record_list_instead_atom = record_list_instead_atom;
exports.record_poly_field_value = record_poly_field_value;
exports.No_variant_match = No_variant_match;
exports.no_variant_match = no_variant_match;
exports.no_matching_variant_found = no_matching_variant_found;
exports.ptag_no_args = ptag_no_args;
exports.ptag_incorrect_n_args = ptag_incorrect_n_args;
exports.ptag_takes_args = ptag_takes_args;
exports.nested_list_invalid_poly_var = nested_list_invalid_poly_var;
exports.empty_list_invalid_poly_var = empty_list_invalid_poly_var;
exports.empty_type = empty_type;
/* No side effect */
