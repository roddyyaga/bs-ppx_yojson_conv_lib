// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Char = require("bs-platform/lib/js/char.js");
var Bi_util = require("./bi_util.bs.js");
var Bi_inbuf = require("./bi_inbuf.bs.js");
var Bi_outbuf = require("./bi_outbuf.bs.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

var match;

if (Bi_util.int_size % 7 === 0) {
  var m = Bi_util.int_size / 7 | 0;
  match = /* tuple */[
    m,
    127
  ];
} else {
  var m$1 = (Bi_util.int_size / 7 | 0) + 1 | 0;
  var h = (1 << Bi_util.int_size % 7) - 1 | 0;
  match = /* tuple */[
    m$1,
    h
  ];
}

var max_highest_byte = match[1];

var max_vint_bytes = match[0];

function check_highest_byte(x) {
  if (x > max_highest_byte) {
    return Bi_util.error("Vint exceeding range of OCaml ints");
  } else {
    return 0;
  }
}

function unsigned_of_signed(i) {
  if (i >= 0) {
    return (i << 1);
  } else {
    return ((-1 - i | 0) << 1) | 1;
  }
}

function write_uvint(buf, i) {
  Bi_outbuf.extend(buf, max_vint_bytes);
  var x = i;
  while((x >>> 7) !== 0) {
    var $$byte = 128 | x & 127;
    Bi_outbuf.unsafe_add_char(buf, Char.chr($$byte));
    x = (x >>> 7);
  };
  return Bi_outbuf.unsafe_add_char(buf, Char.chr(x));
}

function write_svint(buf, i) {
  return write_uvint(buf, unsigned_of_signed(i));
}

function uvint_of_uint(buf, i) {
  var buffer = buf !== undefined ? buf : Bi_outbuf.create(undefined, undefined, 10);
  Bi_outbuf.clear(buffer);
  write_uvint(buffer, i);
  return Bi_outbuf.contents(buffer);
}

function svint_of_int(buf, i) {
  return uvint_of_uint(buf, unsigned_of_signed(i));
}

function read_uvint(ib) {
  var avail = Bi_inbuf.try_preread(ib, max_vint_bytes);
  var s = ib[/* i_s */0];
  var pos = ib[/* i_pos */1];
  var x = 0;
  try {
    for(var i = 0 ,i_finish = avail - 1 | 0; i <= i_finish; ++i){
      var b = Caml_bytes.get(s, pos + i | 0);
      x = ((b & 127) << Caml_int32.imul(7, i)) | x;
      if (b < 128) {
        ib[/* i_pos */1] = (pos + i | 0) + 1 | 0;
        if ((i + 1 | 0) === max_vint_bytes) {
          check_highest_byte(b);
        }
        throw Pervasives.Exit;
      }
      
    }
    Bi_util.error("Unterminated vint or vint exceeding range of OCaml ints");
  }
  catch (exn){
    if (exn !== Pervasives.Exit) {
      throw exn;
    }
    
  }
  return x;
}

function read_svint(ib) {
  var i = read_uvint(ib);
  if ((i & 1) === 0) {
    return (i >>> 1);
  } else {
    return -1 - (i >>> 1) | 0;
  }
}

function check_end_of_input(ib) {
  if (Bi_inbuf.try_preread(ib, 1) > 0) {
    return Bi_util.error("Junk input after end of vint");
  } else {
    return 0;
  }
}

function uint_of_uvint(s) {
  var ib = Bi_inbuf.from_string(undefined, undefined, s);
  var x = read_uvint(ib);
  check_end_of_input(ib);
  return x;
}

function int_of_svint(s) {
  var ib = Bi_inbuf.from_string(undefined, undefined, s);
  var x = read_svint(ib);
  check_end_of_input(ib);
  return x;
}

exports.uvint_of_uint = uvint_of_uint;
exports.svint_of_int = svint_of_int;
exports.uint_of_uvint = uint_of_uvint;
exports.int_of_svint = int_of_svint;
exports.write_uvint = write_uvint;
exports.write_svint = write_svint;
exports.read_uvint = read_uvint;
exports.read_svint = read_svint;
/* Bi_util Not a pure module */
