// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Bi_util = require("./bi_util.bs.js");
var Hashtbl = require("bs-platform/lib/js/hashtbl.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var n = /* record */[/* contents */0];

function create_type_id(param) {
  n[0] = n[0] + 1 | 0;
  if (n[0] < 0) {
    return Pervasives.failwith("Bi_share.Rd_poly.create_type_id: exhausted available type_id's");
  } else {
    return n[0];
  }
}

function equal(param, param$1) {
  if (param[0] === param$1[0]) {
    return param[1] === param$1[1];
  } else {
    return false;
  }
}

var H = Hashtbl.Make({
      equal: equal,
      hash: Hashtbl.hash
    });

var create = H.create;

function clear(tbl) {
  if (Curry._1(H.length, tbl) > 0) {
    return Curry._1(H.clear, tbl);
  } else {
    return 0;
  }
}

function put(tbl, k, pos) {
  try {
    var pos0 = Curry._2(H.find, tbl, k);
    return pos - pos0 | 0;
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      Curry._3(H.add, tbl, k, pos);
      return 0;
    } else {
      throw exn;
    }
  }
}

function create$1(n) {
  return Hashtbl.create(undefined, n);
}

var put$1 = Hashtbl.add;

function get(tbl, pos) {
  try {
    return Hashtbl.find(tbl, pos);
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return Bi_util.error("Corrupted data (invalid reference)");
    } else {
      throw exn;
    }
  }
}

var Rd = {
  create: create$1,
  clear: Hashtbl.clear,
  put: put$1,
  get: get
};

var dummy_type_id = 0;

var Wr = {
  create: create,
  clear: clear,
  put: put
};

exports.dummy_type_id = dummy_type_id;
exports.create_type_id = create_type_id;
exports.Wr = Wr;
exports.Rd = Rd;
/* H Not a pure module */
