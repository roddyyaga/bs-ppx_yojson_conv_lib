// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Bi_share = require("./bi_share.bs.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");

var End_of_input = Caml_exceptions.create("Bi_inbuf.End_of_input");

function try_preread(ib, n) {
  if ((ib[/* i_len */2] - ib[/* i_pos */1] | 0) < n) {
    Curry._2(ib[/* i_refill */5], ib, n);
    return Caml_primitive.caml_int_min(ib[/* i_len */2] - ib[/* i_pos */1] | 0, n);
  } else {
    return n;
  }
}

function read(ib, n) {
  var pos = ib[/* i_pos */1];
  if ((ib[/* i_len */2] - pos | 0) >= n) {
    ib[/* i_pos */1] = pos + n | 0;
    return pos;
  } else if (try_preread(ib, n) >= n) {
    var pos$1 = ib[/* i_pos */1];
    ib[/* i_pos */1] = ib[/* i_pos */1] + n | 0;
    return pos$1;
  } else {
    throw End_of_input;
  }
}

function read_char(ib) {
  var pos = ib[/* i_pos */1];
  if ((ib[/* i_len */2] - pos | 0) > 0) {
    var c = ib[/* i_s */0][pos];
    ib[/* i_pos */1] = pos + 1 | 0;
    return c;
  } else if (try_preread(ib, 1) > 0) {
    var pos$1 = ib[/* i_pos */1];
    var c$1 = ib[/* i_s */0][pos$1];
    ib[/* i_pos */1] = pos$1 + 1 | 0;
    return c$1;
  } else {
    throw End_of_input;
  }
}

function peek(ib) {
  var pos = ib[/* i_pos */1];
  if ((ib[/* i_len */2] - pos | 0) > 0) {
    return ib[/* i_s */0][pos];
  } else if (try_preread(ib, 1) > 0) {
    return ib[/* i_s */0][ib[/* i_pos */1]];
  } else {
    throw End_of_input;
  }
}

function from_bytes($staropt$star, $staropt$star$1, s) {
  var pos = $staropt$star !== undefined ? $staropt$star : 0;
  var shrlen = $staropt$star$1 !== undefined ? $staropt$star$1 : 16;
  return /* record */[
          /* i_s */s,
          /* i_pos */pos,
          /* i_len */s.length,
          /* i_offs */-pos | 0,
          /* i_max_len */s.length,
          /* i_refill */(function (ib, n) {
              return /* () */0;
            }),
          /* i_shared */Bi_share.Rd.create(shrlen)
        ];
}

function from_string(pos, shrlen, s) {
  return from_bytes(pos, shrlen, Bytes.of_string(s));
}

function not_really_input(ic, s, _pos, _len, _accu) {
  while(true) {
    var accu = _accu;
    var len = _len;
    var pos = _pos;
    var n = Pervasives.input(ic, s, pos, len);
    if (n < len && n > 0) {
      _accu = accu + n | 0;
      _len = len - n | 0;
      _pos = pos + n | 0;
      continue ;
    } else {
      return accu + n | 0;
    }
  };
}

function from_channel($staropt$star, $staropt$star$1, ic) {
  var len = $staropt$star !== undefined ? $staropt$star : 4096;
  var shrlen = $staropt$star$1 !== undefined ? $staropt$star$1 : 16;
  return /* record */[
          /* i_s */Caml_bytes.caml_create_bytes(len),
          /* i_pos */0,
          /* i_len */0,
          /* i_offs */0,
          /* i_max_len */len,
          /* i_refill */(function (param, param$1) {
              var ic$1 = ic;
              var ib = param;
              var n = param$1;
              if (n > ib[/* i_max_len */4]) {
                return Pervasives.invalid_arg("Bi_inbuf.refill_from_channel");
              } else {
                var rem_len = ib[/* i_len */2] - ib[/* i_pos */1] | 0;
                if (rem_len < n) {
                  var s = ib[/* i_s */0];
                  Bytes.blit(s, ib[/* i_pos */1], s, 0, rem_len);
                  var to_read = n - rem_len | 0;
                  var really_read = not_really_input(ic$1, s, rem_len, to_read, 0);
                  ib[/* i_offs */3] = ib[/* i_offs */3] + ib[/* i_pos */1] | 0;
                  ib[/* i_pos */1] = 0;
                  ib[/* i_len */2] = rem_len + really_read | 0;
                  return /* () */0;
                } else {
                  return 0;
                }
              }
            }),
          /* i_shared */Bi_share.Rd.create(shrlen)
        ];
}

exports.End_of_input = End_of_input;
exports.try_preread = try_preread;
exports.read = read;
exports.read_char = read_char;
exports.peek = peek;
exports.from_string = from_string;
exports.from_bytes = from_bytes;
exports.from_channel = from_channel;
/* Bi_share Not a pure module */
