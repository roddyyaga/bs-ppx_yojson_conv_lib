// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Sys = require("bs-platform/lib/js/sys.js");
var Bytes = require("bs-platform/lib/js/bytes.js");
var Curry = require("bs-platform/lib/js/curry.js");
var $$String = require("bs-platform/lib/js/string.js");
var Bi_share = require("./bi_share.bs.js");
var Caml_bytes = require("bs-platform/lib/js/caml_bytes.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Caml_oo_curry = require("bs-platform/lib/js/caml_oo_curry.js");
var Caml_primitive = require("bs-platform/lib/js/caml_primitive.js");

function really_extend(b, n) {
  var slen0 = b[/* o_max_len */1];
  var reqlen = b[/* o_len */2] + n | 0;
  var x = Caml_primitive.caml_int_max(reqlen, (slen0 << 1));
  var slen = x <= Sys.max_string_length ? x : (
      Sys.max_string_length < reqlen ? Pervasives.invalid_arg("Buf.extend: reached Sys.max_string_length") : Sys.max_string_length
    );
  var s = Caml_bytes.caml_create_bytes(slen);
  Bytes.blit(b[/* o_s */0], 0, s, 0, b[/* o_len */2]);
  b[/* o_s */0] = s;
  b[/* o_max_len */1] = slen;
  return /* () */0;
}

function flush_to_output(abstract_output, b, n) {
  Curry._3(abstract_output, Bytes.to_string(b[/* o_s */0]), 0, b[/* o_len */2]);
  b[/* o_offs */3] = b[/* o_offs */3] + b[/* o_len */2] | 0;
  b[/* o_len */2] = 0;
  if (n > b[/* o_max_len */1]) {
    return really_extend(b, n);
  } else {
    return 0;
  }
}

function flush_to_channel(oc) {
  return (function (param, param$1) {
      return flush_to_output((function (param, param$1, param$2) {
                    return Pervasives.output_substring(oc, param, param$1, param$2);
                  }), param, param$1);
    });
}

function create($staropt$star, $staropt$star$1, n) {
  var make_room = $staropt$star !== undefined ? $staropt$star : really_extend;
  var shrlen = $staropt$star$1 !== undefined ? $staropt$star$1 : 16;
  return /* record */[
          /* o_s */Caml_bytes.caml_create_bytes(n),
          /* o_max_len */n,
          /* o_len */0,
          /* o_offs */0,
          /* o_init_len */n,
          /* o_make_room */make_room,
          /* o_shared */Curry._1(Bi_share.Wr.create, shrlen),
          /* o_shared_init_len */shrlen
        ];
}

function create_channel_writer($staropt$star, shrlen, oc) {
  var len = $staropt$star !== undefined ? $staropt$star : 4096;
  return create(flush_to_channel(oc), shrlen, len);
}

function flush_channel_writer(b) {
  return Curry._2(b[/* o_make_room */5], b, 0);
}

function create_output_writer($staropt$star, shrlen, out) {
  var len = $staropt$star !== undefined ? $staropt$star : 4096;
  var partial_arg = Caml_oo_curry.js1(209784577, 1, out);
  return create((function (param, param$1) {
                return flush_to_output(partial_arg, param, param$1);
              }), shrlen, len);
}

function extend(b, n) {
  if ((b[/* o_len */2] + n | 0) > b[/* o_max_len */1]) {
    return Curry._2(b[/* o_make_room */5], b, n);
  } else {
    return 0;
  }
}

function alloc(b, n) {
  extend(b, n);
  var pos = b[/* o_len */2];
  b[/* o_len */2] = pos + n | 0;
  return pos;
}

function add_sub(blit, b, s, pos, len) {
  extend(b, len);
  Curry._5(blit, s, pos, b[/* o_s */0], b[/* o_len */2], len);
  b[/* o_len */2] = b[/* o_len */2] + len | 0;
  return /* () */0;
}

function add_substring(param, param$1, param$2, param$3) {
  return add_sub($$String.blit, param, param$1, param$2, param$3);
}

function add_subbytes(param, param$1, param$2, param$3) {
  return add_sub(Bytes.blit, param, param$1, param$2, param$3);
}

function add_string(b, s) {
  return add_substring(b, s, 0, s.length);
}

function add_bytes(b, s) {
  return add_subbytes(b, s, 0, s.length);
}

function add_char(b, c) {
  var pos = alloc(b, 1);
  b[/* o_s */0][pos] = c;
  return /* () */0;
}

function unsafe_add_char(b, c) {
  var len = b[/* o_len */2];
  b[/* o_s */0][len] = c;
  b[/* o_len */2] = len + 1 | 0;
  return /* () */0;
}

function add_char2(b, c1, c2) {
  var pos = alloc(b, 2);
  var s = b[/* o_s */0];
  s[pos] = c1;
  s[pos + 1 | 0] = c2;
  return /* () */0;
}

function add_char4(b, c1, c2, c3, c4) {
  var pos = alloc(b, 4);
  var s = b[/* o_s */0];
  s[pos] = c1;
  s[pos + 1 | 0] = c2;
  s[pos + 2 | 0] = c3;
  s[pos + 3 | 0] = c4;
  return /* () */0;
}

function clear(b) {
  b[/* o_offs */3] = 0;
  b[/* o_len */2] = 0;
  return Bi_share.Wr.clear(b[/* o_shared */6]);
}

function reset(b) {
  if (b[/* o_s */0].length !== b[/* o_init_len */4]) {
    b[/* o_s */0] = Caml_bytes.caml_create_bytes(b[/* o_init_len */4]);
  }
  b[/* o_offs */3] = 0;
  b[/* o_len */2] = 0;
  b[/* o_shared */6] = Curry._1(Bi_share.Wr.create, b[/* o_shared_init_len */7]);
  return /* () */0;
}

function contents(b) {
  return Bytes.sub_string(b[/* o_s */0], 0, b[/* o_len */2]);
}

var flush_output_writer = flush_channel_writer;

exports.really_extend = really_extend;
exports.flush_to_channel = flush_to_channel;
exports.create = create;
exports.contents = contents;
exports.create_channel_writer = create_channel_writer;
exports.flush_channel_writer = flush_channel_writer;
exports.create_output_writer = create_output_writer;
exports.flush_output_writer = flush_output_writer;
exports.extend = extend;
exports.alloc = alloc;
exports.add_bytes = add_bytes;
exports.add_subbytes = add_subbytes;
exports.add_string = add_string;
exports.add_substring = add_substring;
exports.add_char = add_char;
exports.add_char2 = add_char2;
exports.add_char4 = add_char4;
exports.unsafe_add_char = unsafe_add_char;
exports.clear = clear;
exports.reset = reset;
/* Bi_share Not a pure module */
